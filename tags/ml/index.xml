<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ml on Yi Chen</title><link>https://ychen878.github.io/tags/ml/</link><description>Recent content in Ml on Yi Chen</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 02 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://ychen878.github.io/tags/ml/index.xml" rel="self" type="application/rss+xml"/><item><title>Nuclear Norm via SDP</title><link>https://ychen878.github.io/notes/nuclear-norm-sdp/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><guid>https://ychen878.github.io/notes/nuclear-norm-sdp/</guid><description>&lt;p&gt;:PROPERTIES:
:CUSTOM_ID: matrix-norm
:END:&lt;/p&gt;
&lt;h1 id="matrix-norms"&gt;Matrix norms&lt;/h1&gt;
&lt;p&gt;Given a matrix $X \in \mathbb{R}^{m \times n}$, $\sigma_{i}(X)$ denotes the $i$-th largest singular value of $X$ and is equal to the square root of the $i$-th largest eigenvalue of $XX&amp;rsquo;$. The rank of $X$, denoted as $\mathrm{rank}(X) = r$ is the number of non-zero singular values.&lt;/p&gt;
&lt;h2 id="inner-product"&gt;Inner Product&lt;/h2&gt;
&lt;p&gt;Given $X, Y \in \mathbb{R}^{m \times n}$, the inner product between $X$ and $Y$, denoted by $\langle X, Y\rangle$, is defined as
$$
\langle X, Y \rangle := \mathrm{Tr}(X&amp;rsquo;Y) = \sum_{i=1}^m \sum_{j=1}^n X_{ij}Y_{ij} = \mathrm{Tr}(Y&amp;rsquo;X).
$$&lt;/p&gt;</description></item><item><title>Perceptron Learning Algorithm</title><link>https://ychen878.github.io/notes/pla/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://ychen878.github.io/notes/pla/</guid><description>&lt;p&gt;
Given a dataset
\(\mathcal{D} = \{(\vec{x}_1, y_1), \cdots, (\vec{x}_N, y_N)\}\) and a
hypothesis set \(\mathcal{H}\), our learning algorithm \(\mathcal{A}\)
tries to learn a function \(g \in \mathcal{H}\) that approximates the
underlying, true function \(f: \mathcal{X} \to \mathcal{Y}\), which
generates the points in \(\mathcal{D}\).&lt;/p&gt;
&lt;div id="outline-container-credit-card-approve-problem" class="outline-3"&gt;
&lt;h3 id="credit-card-approve-problem"&gt;
Credit Card Approve Problem
&lt;/h3&gt;
&lt;div id="outline-text-credit-card-approve-problem" class="outline-text-3"&gt;
&lt;p&gt;Given a customer who is applying for a credit card, we want to build a
system that determines if we should grant the application or not based
on the customer&amp;#39;s information such as age, annual salary, year in job,
etc. The bank&amp;#39;s historical credit approval data can be seen as a dataset
\(\mathcal{D} = \{(\vec{x}_i, y_i)\}_{i=1}^N\)where each
\(\vx_i \in \mathcal{X}\) and each represents a customer. There is a
target function \(f: \mathcal{X} \to \mathcal{Y}\) that gives \(\vx\)&amp;#39;s
credit behavior \(f(\vec{x}) = y\). Each \(\vx\) is a multidimensional
vector where each component is a feature (age, for example). Our
learning algorithm \(\mathcal{A}\) considers a hypothesis class
\(\mathcal{H}\) and takes the dataset \(\mathcal{D}\) and tries to give
a function \(g \in \mathcal{H}\) so that \(g\) performs similar to
\(f\). We will use \(g\) as our system of approving credit card.&lt;/p&gt;</description></item><item><title>Clustering</title><link>https://ychen878.github.io/notes/clustering/</link><pubDate>Sat, 08 Oct 2022 00:00:00 +0000</pubDate><guid>https://ychen878.github.io/notes/clustering/</guid><description>&lt;p&gt;
In unsupervised learning, there are no labels associated with features.
Generally speaking, the ultimate goal of unsupervised learning is to
find patterns and structures that help us to better understand data.
Sometimes, we also use unsupervised learning to model a distribution.
But we generally will not make predictions.&lt;/p&gt;
&lt;p&gt;
There are 3 types of clustering 1. Partitional (centroid,
graph-theoretic, spectral) 1. Hierarchical (agglomerative, divisive) 2.
Bayesian (decision-based, non-parametric)&lt;/p&gt;
&lt;div id="outline-container-partitional-clustering" class="outline-3"&gt;
&lt;h3 id="partitional-clustering"&gt;
Partitional Clustering
&lt;/h3&gt;
&lt;div id="outline-text-partitional-clustering" class="outline-text-3"&gt;
&lt;div id="outline-container-k-means" class="outline-4"&gt;
&lt;h4 id="k-means"&gt;
\(k\)-means
&lt;/h4&gt;
&lt;div id="outline-text-k-means" class="outline-text-4"&gt;
&lt;p&gt;\(k\)-means is a type of partitional centroid-based clustering
algorithm. The algorithm is described as follows: 1. Randomly pick \(k\)
cluster centers; 2. Find the closest center for each point; 3. Update
cluster centers by computing centroids; 4. While not converging, jump to
step 2.&lt;/p&gt;</description></item><item><title>K-means in Python</title><link>https://ychen878.github.io/notes/k-means/</link><pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate><guid>https://ychen878.github.io/notes/k-means/</guid><description>&lt;p&gt;There are two major steps in the K-means algorithm. The first one is to
calculate the representatives (centroids) of a given partition. The
second one is to find the partition based on the representatives.&lt;/p&gt;
&lt;div id="outline-container-inputs" class="outline-3"&gt;
&lt;h3 id="inputs"&gt;
Inputs
&lt;/h3&gt;
&lt;div id="outline-text-inputs" class="outline-text-3"&gt;
&lt;p&gt;Suppose we have a dataset looks like this:&lt;/p&gt;
&lt;div class="src src-python"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;dataset &lt;span style="color:#f92672"&gt;=&lt;/span&gt; np&lt;span style="color:#f92672"&gt;.&lt;/span&gt;array([[&lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;6&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; [&lt;span style="color:#ae81ff"&gt;6&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; [&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; [&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; [&lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;]])&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Each row in this dataset matrix is an observation and each column in
this matrix represents a feature. So, in this example, we have 5 points
from a plane. And we define partition in the following way:&lt;/p&gt;</description></item></channel></rss>